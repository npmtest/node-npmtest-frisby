{"/home/travis/build/npmtest/node-npmtest-frisby/test.js":"/* istanbul instrument in package npmtest_frisby */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-frisby/lib.npmtest_frisby.js":"/* istanbul instrument in package npmtest_frisby */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_frisby = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_frisby = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-frisby/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-frisby && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_frisby */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_frisby\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_frisby.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_frisby.rollup.js'] =\n            local.assetsDict['/assets.npmtest_frisby.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_frisby.__dirname +\n                    '/lib.npmtest_frisby.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-frisby/node_modules/frisby/lib/frisby.js":"//\n// Frisby.js\n// (c) 2011-2014 Vance Lucas, Brightbit, LLC\n//\n// Frisby is a library designed to easily test REST API endpoints and their responses with node.js and Jasmine\n//\n// Frisby is distributed under the BSD license\n// http://www.opensource.org/licenses/bsd-license.php\n//\nvar qs = require('qs')\n  , util = require('util')\n  , request = require('request')\n  , _ = require('underscore')\n  , JSONSchemaValidator = require('jsonschema').Validator\n  , stackTrace = require('stack-trace')\n  , fs = require('fs')\n  , fspath = require('path')\n  , Stream = require('stream').Stream;\n\n\n//\n// Frisby global setup object config\n//\nvar _frisbyGlobalSetup = {\n  request: {\n    headers: {},\n    inspectOnFailure: false,\n    json: false,\n    baseUri: ''\n  }\n};\nvar globalSetup = function(opts) {\n  if(typeof opts !== \"undefined\") {\n    _frisbyGlobalSetup = opts;\n    if(typeof _frisbyGlobalSetup.request === \"undefined\") {\n      _frisbyGlobalSetup.request = {};\n      _frisbyGlobalSetup.request.headers = {};\n      _frisbyGlobalSetup.request.inspectOnFailure = false;\n      _frisbyGlobalSetup.request.json = false;\n      _frisbyGlobalSetup.request.baseUri = '';\n    }\n  }\n  return _frisbyGlobalSetup;\n};\n\n\nvar _toType = function(obj) {\n  return ({}).toString.call(obj).match(/\\s([a-z|A-Z]+)/)[1].toLowerCase();\n};\n\n\n// Path execution method\nvar _withPath = function(path, jsonBody, callback) {\n  var self = this\n    , type = false;\n\n  try {\n    // Use given path to check deep objects\n    if(path) {\n      var pathParts = path.split('.');\n      _.each(path.split('.'), function(segment) {\n        var jt = _toType(jsonBody);\n        // Must be array if special characters are present\n        if(\"*\" === segment || \"?\" === segment) {\n          type = segment;\n\n          if(\"array\" !== jt) {\n            throw new TypeError(\"Expected '\" + path + \"' to be Array (got '\" + jt + \"' from JSON response)\");\n          }\n        } else if(\"&\" === segment) {\n          type = segment;\n\n          if(\"object\" !== jt) {\n            throw new TypeError(\"Expected '\" + path + \"' to be Object (got '\" + jt + \"' from JSON response)\");\n          }\n        } else {\n          jsonBody = jsonBody[segment];\n\n          // Must be object\n          if(\"object\" !== jt && \"array\" !== jt) {\n            throw new TypeError(\"Expected '\" + path + \"' to be object or array (got '\" + jt + \"' from JSON response)\");\n          }\n        }\n      });\n    }\n  } catch(e) {\n    throw e;\n  }\n\n  // EACH item in array should match\n  if(\"*\" === type || \"&\" === type) {\n    _.each(jsonBody, function(json) {\n      callback.call(null, json);\n    });\n\n  // ONE item in array should match\n  } else if(\"?\" === type) {\n    var itemCount = jsonBody.length;\n    var errorCount = 0;\n    var errorLast;\n\n    for(var i = 0; i < itemCount; i++) {\n      try {\n        var result = callback.call(null, jsonBody[i]);\n      } catch (e) {\n        errorCount++;\n        errorLast = e;\n      }\n    };\n\n    // If all errors, test fails\n    if(itemCount === errorCount) {\n      if(errorLast) {\n        throw errorLast;\n      } else {\n        throw new Error(\"Expected one object in path '\" + path + \"' to match provided JSON values\");\n      }\n    }\n\n  // Normal matcher\n  } else {\n    return callback.call(null, jsonBody);\n  }\n};\n\n\nvar cloneObject = function(obj) {\n  var clone = {};\n  for(var i in obj) {\n    if(typeof(obj[i])==\"object\")\n      clone[i] = cloneObject(obj[i]);\n    else\n      clone[i] = obj[i];\n  }\n  return clone;\n};\n\n\n//\n// Frisby object\n//\nfunction Frisby(msg) {\n  // Clone globalSetup (not reference)\n  var _gs = cloneObject(globalSetup());\n  // _gs may contain mixed-cased header names, the code expects lowercase however.\n  if(_gs.request && _gs.request.headers) {\n    var _tmpHeaders = {};\n    _.each(_gs.request.headers, function(val, key) {\n      _tmpHeaders[(key+\"\").toLowerCase()] = val+\"\";\n    });\n    _gs.request.headers = _tmpHeaders;\n  }\n\n  // Optional exception handler\n  this._exceptionHandler = false;\n\n  // Spec storage\n  this.current = {\n    outgoing: {},\n    describe: msg,\n    itInfo: null,\n    it: null,\n    isNot: false, // For Jasmine test negation\n    expects: [],\n    after: [],\n    retry: _gs.retry || 0,\n    retry_backoff: _gs.retry_backoff || 1000,\n\n    // Custom vars added to test HTTP Request (like headers)\n    request: _gs.request,\n\n    // Response storage\n    response: {\n      error: null,\n      status: null,\n      headers: [],\n      body: null,\n      time: 0\n    }\n  };\n  this.currentRequestFinished = false;\n\n  // Default timeout\n  this._timeout = _gs.timeout || 5000;\n\n  // Response type\n  this.responseType = 'json';\n\n  return this;\n}\n\n\n//\n// Timeout getter and setter\n//\n// @param int Timeout in seconds\n//\nFrisby.prototype.timeout = function(t) {\n  var t = t || null;\n  if(null === t) {\n    return this._timeout;\n  }\n  this._timeout = t;\n  return this;\n};\n\n\n//\n// Reset Frisby global and setup options\n//\nFrisby.prototype.reset = function() {\n  this.current.request = {\n    headers: {}\n  };\n  return this;\n};\n\n\n//\n// Set negation test\n//\nFrisby.prototype.not = function() {\n  this.current.isNot = true;\n  return this;\n};\n\n\n//\n// Add HTTP header by key and value\n//\n// @param string header key\n// @param string header value content\n//\nFrisby.prototype.addHeader = function(header, content) {\n  this.current.request.headers[(header+\"\").toLowerCase()] = content+\"\";\n  return this;\n};\n\n//\n// Add group of HTTP headers together\n//\nFrisby.prototype.addHeaders = function (headers) {\n  var self = this;\n  _.each(headers, function(val, key) {\n    self.addHeader(key, val);\n  });\n  return this;\n};\nFrisby.prototype.setHeaders = function(headers) {\n  console.warn(\"\\nMethod 'setHeaders' is DEPRECATED and will be removed soon. Please use 'addHeaders' method instead.\\nIn Spec: '\" + this.current.describe + \"'\\n\");\n  return this.addHeaders(headers);\n};\n\n//\n// Remove HTTP header from outgoing request by key\n//\n// @param string header key\n//\nFrisby.prototype.removeHeader = function (key) {\n  delete this.current.request.headers[(key+\"\").toLowerCase()];\n  return this;\n};\n\n\n//\n// Return response type\n//\n// @param {Object}\n//\nFrisby.prototype.responseType = function(type) {\n  this.responseType = type;\n  return this;\n};\n\n\n//\n// HTTP Basic Auth\n//\n// @param string username\n// @param string password\n// @param boolean digest\n//\nFrisby.prototype.auth = function(user, pass, digest) {\n  this.current.outgoing.auth = {\n    sendImmediately: !digest,\n    user: user,\n    pass: pass\n  };\n  return this;\n};\n\n\n// HTTP Request\nFrisby.prototype.get = function (/* [uri, params] */) {\n  var args = Array.prototype.slice.call(arguments);\n  args.splice(1, -1, null);\n  return this._request.apply(this, ['GET'].concat(args));\n};\n\nFrisby.prototype.patch = function (/* [uri, data, params] */) {\n  var args = Array.prototype.slice.call(arguments);\n  return this._request.apply(this, ['PATCH'].concat(args));\n};\n\nFrisby.prototype.post = function (/* [uri, data, params] */) {\n  var args = Array.prototype.slice.call(arguments);\n  return this._request.apply(this, ['POST'].concat(args));\n};\n\nFrisby.prototype.put = function (/* [uri, data, params] */) {\n  var args = Array.prototype.slice.call(arguments);\n  return this._request.apply(this, ['PUT'].concat(args));\n};\n\nFrisby.prototype.delete = function (/* [uri, data, params] */) {\n  var args = Array.prototype.slice.call(arguments);\n  return this._request.apply(this, ['DELETE'].concat(args));\n};\n\nFrisby.prototype.head = function (/* [uri, params] */) {\n  var args = Array.prototype.slice.call(arguments);\n  args.splice(1, -1, null);\n  return this._request.apply(this, ['HEAD'].concat(args));\n};\n\nFrisby.prototype.options = function (/* [uri, params] */) {\n    var args = Array.prototype.slice.call(arguments);\n    args.splice(1, -1, null);\n    return this._request.apply(this, ['OPTIONS'].concat(args));\n};\n\nvar _hasHeader = function (headername, headers) {\n  var headerNames = Object.keys(headers || {});\n  var lowerNames = headerNames.map(function (name) {return name.toLowerCase()});\n  var lowerName = headername.toLowerCase()\n  for (var i=0;i<lowerNames.length;i++) {\n    if (lowerNames[i] === lowerName) return headerNames[i]\n  }\n  return false\n};\n\nFrisby.prototype._request = function (/* method [uri, data, params] */) {\n  var self    = this,\n      args    = Array.prototype.slice.call(arguments),\n      method  = args.shift(),\n      uri     = typeof args[0] === 'string' && args.shift(),\n      data    = typeof args[0] === 'object' && args.shift(),\n      params  = typeof args[0] === 'object' && args.shift(),\n      port    = this.port && this.port !== 80 ? ':' + this.port : '',\n      fullUri,\n      outgoing = {\n        json: params.json || (_frisbyGlobalSetup && _frisbyGlobalSetup.request && _frisbyGlobalSetup.request.json || false),\n        uri: null,\n        body: params.body || null,\n        method: 'GET',\n        headers: {}\n      };\n\n  // Explicit setting of 'body' param overrides data\n  if(params.body) {\n    data = params.body;\n  }\n\n  // Merge 'current' request options for current request\n  _.extend(outgoing, this.current.request, params || {});\n\n  // Normalize content-type\n\n  var contentTypeKey = _hasHeader('content-type', outgoing.headers);\n  if(contentTypeKey !== 'content-type') {\n      outgoing.headers['content-type'] = outgoing.headers[contentTypeKey];\n      delete outgoing.headers[contentTypeKey];\n  }\n\n  // Ensure we have at least one 'content-type' header\n  if(_.isUndefined(outgoing.headers['content-type'])) {\n    outgoing.headers['content-type'] = 'application/x-www-form-urlencoded';\n  }\n\n  // Set outgoing URI\n  outgoing.uri = (_frisbyGlobalSetup && _frisbyGlobalSetup.request && _frisbyGlobalSetup.request.baseUri || '') + uri;\n\n  //\n  // If the user has provided data, assume that it is query string\n  // and set it to the `body` property of the options.\n  //\n  if (data) {\n    // if JSON data\n    if(outgoing.json) {\n      outgoing.headers['content-type'] = 'application/json';\n      outgoing.body = data;\n    } else if(!outgoing.body) {\n      if(data instanceof Buffer) {\n        outgoing.body = data;\n      } else if (!(data instanceof Stream)) {\n        outgoing.body = qs.stringify(data);\n      }\n    }\n  }\n\n  //\n  // Set the `uri` and `method` properties of the request options `outgoing`\n  // using the information provided to this instance and `_request()`.\n  //\n  outgoing.method = method;\n\n  //\n  // Store outgoing request on current Frisby object for inspection if needed\n  //\n  this.current.outgoing = outgoing;\n\n  //\n  // Create the description for this test based on the METHOD and URL\n  //\n  this.current.itInfo = method.toUpperCase() + ' ' + outgoing.uri;\n\n  //\n  // Determine test runner function (request or provided mock)\n  //\n  var runner = params.mock || request;\n\n  //\n  // Add the topic for the specified request to the context of the current\n  // batch used by this suite.\n  //\n  this.current.it = function () {\n    self.currentRequestFinished = false;\n    var start = (new Date).getTime();\n    var runCallback = function(err, res, body) {\n\n      // Timeout is now handled by request\n      if(err) {\n        body = \"Destination URL may be down or URL is invalid, \" + err;\n      }\n\n      var diff = (new Date).getTime() - start;\n\n      self.currentRequestFinished = {err: err, res: res, body: body, req: outgoing};\n\n      // Convert header names to lowercase\n      var headers = {};\n      res && _.each(res.headers, function(val, key) {\n        headers[(key+\"\").toLowerCase()] = val;\n      });\n      // Store relevant current response parts\n      self.current.response = {\n        error: err,\n        status: (res ? res.statusCode : 500),\n        headers: headers,\n        body: body,\n        time: diff\n      };\n    };\n\n    outgoing['timeout'] = self._timeout;\n\n    var req = null;\n\n    // Handle forms (normal data with {form: true} in params options)\n    if(!_.isUndefined(params.form) && params.form === true) {\n      delete outgoing.headers['content-type'];\n      req = runner(outgoing, runCallback);\n      var form = req.form();\n      for(field in data) {\n        form.append(field, data[field]);\n      }\n    } else {\n      req = runner(outgoing, runCallback);\n    }\n\n    if((data instanceof Stream) && (outgoing.method === 'POST' || outgoing.method === 'PUT' || outgoing.method === 'PATCH'))  {\n        data.pipe(req);\n    }\n\n  };\n\n  return this;\n};\n\n// Max Response time expect helper\nFrisby.prototype.expectMaxResponseTime = function(milliseconds) {\n  var self = this;\n  this.current.expects.push(function() {\n    expect(self.current.response.time).toBeLessThan(milliseconds);\n  })\n  return this;\n};\n\n// HTTP status expect helper\nFrisby.prototype.expectStatus = function(statusCode) {\n  var self = this;\n  this.current.expects.push(function() {\n    expect(self.current.response.status).toEqual(statusCode);\n  })\n  return this;\n};\n\n// HTTP header expect helper\nFrisby.prototype.expectHeader = function(header, content) {\n  var self = this;\n  var header = (header+\"\").toLowerCase();\n  this.current.expects.push(function() {\n    if(typeof self.current.response.headers[header] !== \"undefined\") {\n      expect(self.current.response.headers[header].toLowerCase()).toEqual(content.toLowerCase());\n    } else {\n      throw new Error(\"Header '\" + header + \"' not present in HTTP response\");\n    }\n  });\n  return this;\n};\n\n// HTTP header expect helper (less strict version using 'contains' instead of strict 'equals')\nFrisby.prototype.expectHeaderContains = function(header, content) {\n  var self = this;\n  var header = (header+\"\").toLowerCase();\n  this.current.expects.push(function() {\n    if(typeof self.current.response.headers[header] !== \"undefined\") {\n      expect(self.current.response.headers[header].toLowerCase()).toContain(content.toLowerCase());\n    } else {\n      throw new Error(\"Header '\" + header + \"' not present in HTTP response\");\n    }\n  });\n  return this;\n};\n\n// HTTP header expect helper regular expression match\nFrisby.prototype.expectHeaderToMatch = function(header, pattern) {\n    var self = this;\n    var header = (header+\"\").toLowerCase();\n    this.current.expects.push(function() {\n        if(typeof self.current.response.headers[header] !== \"undefined\") {\n            expect(self.current.response.headers[header].toLowerCase()).toMatch(pattern);\n        } else {\n            throw new Error(\"Header '\" + header + \"' does not match pattern '\" + pattern + \"' in HTTP response\");\n        }\n    });\n    return this;\n};\n\n// HTTP body expect helper\nFrisby.prototype.expectBodyContains = function(content) {\n  var self = this;\n  this.current.expects.push(function() {\n    if(!_.isUndefined(self.current.response.body)) {\n      expect(self.current.response.body).toContain(content);\n    } else {\n      throw new Error(\"No HTTP response body was present or HTTP response was empty\");\n    }\n  });\n  return this;\n};\n\n// Helper to check parse HTTP response body as JSON and check key types\nFrisby.prototype.expectJSONTypes = function(/* [tree], jsonTest */) {\n  var self     = this,\n      args     = Array.prototype.slice.call(arguments),\n      path     = typeof args[0] === 'string' && args.shift(),\n      jsonTest = typeof args[0] === 'object' && args.shift(),\n      type     = null;\n\n  this.current.expects.push(function() {\n    var jsonBody = _jsonParse(self.current.response.body);\n    var jt = _toType(jsonBody);\n    try {\n      // Use given path to check deep objects\n      if(path) {\n        _.each(path.split('.'), function(segment) {\n          jt = _toType(jsonBody);\n\n          // Must be array if special characters are present\n          if(\"*\" === segment || \"?\" === segment ) {\n            type = segment;\n\n            // Must be array\n            if(\"array\" !== jt) {\n              throw new TypeError(\"Expected '\" + path + \"' to be Array (got '\" + jt + \"' from JSON response)\");\n            }\n          } else if(\"&\" === segment) {\n            type = segment;\n\n            // Must be object\n            if(\"object\" !== jt) {\n              throw new TypeError(\"Expected '\" + path + \"' to be Object (got '\" + jt + \"' from JSON response)\");\n            }\n          } else {\n            jsonBody = jsonBody[segment];\n\n            // Must be object or array\n            if(\"object\" !== jt && \"array\" !== jt) {\n              throw new TypeError(\"Expected '\" + path + \"' to be object or array (got '\" + jt + \"' from JSON response)\");\n            }\n          }\n        });\n      }\n    } catch(e) {\n      if(!self.current.isNot) {\n        throw e;\n      }\n    }\n\n    // EACH item in array should match\n    if(\"*\" === type || \"&\" === type) {\n      _.each(jsonBody, function(json) {\n        expect(json).toContainJsonTypes(jsonTest, self.current.isNot);\n      });\n\n    // ONE item in array should match\n    } else if(\"?\" === type) {\n      var itemCount = jsonBody.length;\n      var errorCount = 0;\n      var errorLast;\n\n      for(var i = 0; i < itemCount; i++) {\n        try {\n          var result = _jsonContainsTypes(jsonBody[i], jsonTest, self.current.isNot);\n        } catch (e) {\n          errorCount++;\n          errorLast = e;\n        }\n      };\n\n      // If all errors, test fails\n      if(itemCount === errorCount && !self.current.isNot) {\n        if(errorLast) {\n          throw errorLast;\n        } else {\n          throw new Error(\"Expected one object in path '\" + path + \"' to match provided JSON types\");\n        }\n      }\n\n    // Normal matcher\n    } else {\n      expect(jsonBody).toContainJsonTypes(jsonTest, self.current.isNot);\n    }\n  });\n  return this;\n};\n\n\n// Helper to check parse HTTP response body as JSON and check key types\nFrisby.prototype.expectJSON = function(jsonTest) {\n  var self     = this,\n      args     = Array.prototype.slice.call(arguments),\n      path     = typeof args[0] === 'string' && args.shift(),\n      jsonTest = typeof args[0] === 'object' && args.shift(),\n      params   = typeof args[0] === 'object' && args.shift(),\n      type     = null;\n\n  this.current.expects.push(function() {\n    var jsonBody = _jsonParse(self.current.response.body);\n    try {\n      // Use given path to check deep objects\n      if(path) {\n        _.each(path.split('.'), function(segment) {\n          var jt = _toType(jsonBody);\n          // Must be array if special characters are present\n          if(\"*\" === segment || \"?\" === segment) {\n            type = segment;\n\n            if(\"array\" !== jt) {\n              throw new TypeError(\"Expected '\" + path + \"' to be Array (got '\" + jt + \"' from JSON response)\");\n            }\n          } else if(\"&\" === segment) {\n            type = segment;\n\n            if(\"object\" !== jt) {\n              throw new TypeError(\"Expected '\" + path + \"' to be Object (got '\" + jt + \"' from JSON response)\");\n            }\n          } else {\n            jsonBody = jsonBody[segment];\n\n            // Must be object\n            if(\"object\" !== jt && \"array\" !== jt) {\n              throw new TypeError(\"Expected '\" + path + \"' to be object or array (got '\" + jt + \"' from JSON response)\");\n            }\n          }\n        });\n      }\n    } catch(e) {\n      if(!self.current.isNot) {\n        throw e;\n      }\n    }\n\n    // EACH item in array should match\n    if(\"*\" === type || \"&\" === type) {\n      _.each(jsonBody, function(json) {\n        expect(json).toContainJson(jsonTest, self.current.isNot);\n      });\n\n    // ONE item in array should match\n    } else if(\"?\" === type) {\n      var itemCount = jsonBody.length;\n      var errorCount = 0;\n      var errorLast;\n\n      for(var i = 0; i < itemCount; i++) {\n        try {\n          var result = _jsonContains(jsonBody[i], jsonTest, self.current.isNot);\n        } catch (e) {\n          errorCount++;\n          errorLast = e;\n        }\n      };\n\n      // If all errors, test fails\n      if(itemCount === errorCount && !self.current.isNot) {\n        if(errorLast) {\n          throw errorLast;\n        } else {\n          throw new Error(\"Expected one object in path '\" + path + \"' to match provided JSON values\");\n        }\n      }\n\n    // Normal matcher\n    } else {\n      expect(jsonBody).toContainJson(jsonTest, self.current.isNot);\n    }\n  });\n  return this;\n};\n\n\n// Helper to validate JSON response against provided JSONSchema structure or document\nFrisby.prototype.expectJSONSchema = function(path, jsonSchema) {\n  var self       = this,\n      args       = Array.prototype.slice.call(arguments),\n      path       = typeof args[0] === 'string' && args.shift(),\n      jsonSchema = (typeof args[0] === 'object' || typeof args[0] === 'string') && args.shift();\n\n  // If called with only a single argument, ensure path is null\n  if(_.isUndefined(jsonSchema) || !jsonSchema) {\n    jsonSchema = path;\n    path = false;\n  }\n\n  // String = file path\n  if(typeof jsonSchema === 'string') {\n    var jsonSchemaFile = jsonSchema;\n    // Allows relative file paths from Frisby specs\n    if(!fs.existsSync(jsonSchemaFile)) {\n      var trace       = stackTrace.parse(new Error());\n      var callingFile = trace[1].getFileName();\n      var callingDir  = fspath.dirname(callingFile)\n      jsonSchemaFile = fspath.join(callingDir, jsonSchema);\n    }\n    var data        = fs.readFileSync(jsonSchemaFile, 'utf-8');\n    jsonSchema      = JSON.parse(data);\n  }\n\n  this.current.expects.push(function() {\n    var jsonBody = _jsonParse(self.current.response.body);\n    // With path syntax\n    _withPath.call(self, path, jsonBody, function(jsonChunk) {\n      var jsVal = new JSONSchemaValidator();\n      var res = jsVal.validate(jsonChunk, jsonSchema);\n      if(res.valid === true) {\n        // Use assertion to keep assertion count accurate\n        expect(res.valid).toBeTruthy();\n      } else if (self.current.isNot) {\n        // Inverse expectation\n        expect(res.valid).toBeFalsy();\n      } else {\n        // JSONSchema failures - show each one to user\n        throw new Error(\"JSONSchema validation failed with the following errors: \\n\\t> \" +\n          res.errors.map(function(err, field) { return err.stack.replace('instance', path); }).join(\"\\n\\t> \")\n        );\n      }\n    });\n  });\n\n  return this;\n};\n\n\n// Helper to check parse HTTP response body as JSON and check array or object length\nFrisby.prototype.expectJSONLength = function(expectedLength) {\n  var self           = this,\n      args           = Array.prototype.slice.call(arguments),\n      path           = typeof args[0] === 'string' && args.shift(), // optional 1st parameter\n      expectedLength = (typeof args[0] === 'number' || typeof args[0] === 'string') && args.shift(), // 1st or 2nd parameter\n      type           = null,\n      lengthSegments = {\n        \"count\": parseInt(/\\d+/.exec(expectedLength), 10),\n        \"sign\": /\\D+/.exec(expectedLength)\n      };\n\n  if (lengthSegments.sign && typeof lengthSegments.sign === 'object') {\n    lengthSegments.sign = lengthSegments.sign[0].replace(/^\\s+|\\s+$/g, ''); // trim\n  }\n\n  this.current.expects.push(function() {\n    var jsonBody = _jsonParse(self.current.response.body);\n    // Use given path to check deep objects\n    if(path) {\n      _.each(path.split('.'), function(segment) {\n\n        // Must be array if special characters are present\n        if(\"*\" === segment) {\n          var jt = _toType(jsonBody);\n          type = segment;\n\n          if(\"array\" !== jt) {\n            throw new TypeError(\"Expected '\" + path + \"' to be Array (got '\" + jt + \"' from JSON response)\");\n          }\n        } else {\n          // Traverse down path\n          jsonBody = jsonBody[segment];\n        }\n\n        if(_.isUndefined(jsonBody)) {\n          throw new Error(\"expectJSONLength expected path '\" + path + \"' \");\n        }\n      });\n    }\n\n    // Callback that does the work\n    var expectLength = function(jsonBody, lengthSegments) {\n      var len = 0;\n      if(_toType(jsonBody) == 'object') {\n        len = Object.keys(jsonBody).length;\n      } else {\n        len = jsonBody.length;\n      }\n\n      switch (lengthSegments.sign) {\n        case \"<=\":\n          if(!(len <= lengthSegments.count)) { // Generate useful error message if values don't match\n            throw new Error(\"Expected JSON length to be less than or equal '\" + lengthSegments.count + \"', got '\" + len + \"'\" + (path ? (\" in path '\" + path + \"'\") : \"\"));\n          }\n          expect(len).toBeLessThan(lengthSegments.count+1);\n          break;\n        case \"<\":\n          if(!(len < lengthSegments.count)) { // Generate useful error message if values don't match\n            throw new Error(\"Expected JSON length to be less than '\" + lengthSegments.count + \"', got '\" + len + \"'\" + (path ? (\" in path '\" + path + \"'\") : \"\"));\n          }\n          expect(len).toBeLessThan(lengthSegments.count);\n          break;\n        case \">=\":\n          if(!(len >= lengthSegments.count)) { // Generate useful error message if values don't match\n            throw new Error(\"Expected JSON length to be greater than or equal '\" + lengthSegments.count + \"', got '\" + len + \"'\" + (path ? (\" in path '\" + path + \"'\") : \"\"));\n          }\n          expect(len).toBeGreaterThan(lengthSegments.count-1);\n          break;\n        case \">\":\n          if(!(len > lengthSegments.count)) { // Generate useful error message if values don't match\n            throw new Error(\"Expected JSON length to be greater than '\" + lengthSegments.count + \"', got '\" + len + \"'\" + (path ? (\" in path '\" + path + \"'\") : \"\"));\n          }\n          expect(len).toBeGreaterThan(lengthSegments.count);\n          break;\n        case null:\n          if(len !== lengthSegments.count) {\n            throw new Error(\"Expected JSON length to be '\" + lengthSegments.count + \"', got '\" + len + \"'\" + (path ? (\" in path '\" + path + \"'\") : \"\"));\n          }\n          expect(len).toBe(lengthSegments.count);\n          break;\n      } //end switch\n    }\n\n    // EACH item in array should match\n    if(\"*\" === type) {\n      _.each(jsonBody, function(json) {\n        expectLength(json, lengthSegments);\n      });\n    } else {\n      expectLength(jsonBody, lengthSegments);\n    }\n\n  });\n  return this;\n};\n\n\n// Debugging helper to inspect HTTP request sent by Frisby\nFrisby.prototype.inspectRequest = function() {\n  var self = this;\n  this.after(function(err, res, body) {\n    console.log(self.currentRequestFinished.req);\n  });\n  return this;\n};\n\n// Debugging helper to inspect HTTP response received from server\nFrisby.prototype.inspectResponse = function() {\n  this.after(function(err, res, body) {\n    console.log(res);\n  });\n  return this;\n};\n\n// Debugging helper to inspect the HTTP headers that are returned from the server\nFrisby.prototype.inspectHeaders = function(){\n  this.after(function(err, res, body) {\n    console.log(res.headers);\n  });\n  return this;\n};\n\n// Debugging helper to inspect HTTP response body content received from server\nFrisby.prototype.inspectBody = function() {\n  this.after(function(err, res, body) {\n    console.log(body);\n  });\n  return this;\n};\n\n// Debugging helper to inspect JSON response body content received from server\nFrisby.prototype.inspectJSON = function() {\n  this.after(function(err, res, body) {\n    console.log(util.inspect(_jsonParse(body), false, 10, true));\n  });\n  return this;\n};\n\n// Debugging helper to inspect HTTP response code received from server\nFrisby.prototype.inspectStatus = function() {\n  this.after(function(err, res, body) {\n    console.log(res.statusCode);\n  });\n  return this;\n};\n\nFrisby.prototype.retry = function(count, backoff) {\n  this.current.retry = count;\n  if(typeof backoff !== \"undefined\") {\n    this.current.retry_backoff = backoff;\n  }\n  return this;\n};\n\nFrisby.prototype.waits = function(millis) {\n  this.current.waits = millis;\n  return this;\n}\n\n// Callback function to run after test is completed\nFrisby.prototype.after = function(cb) {\n  var self = this;\n  this.current.after.push(function() {\n    cb.call(this, self.current.response.error, self.currentRequestFinished.res, self.current.response.body);\n  });\n  return this;\n};\n\n// Callback function to run after test is completed\n// Helper to also automatically convert response body to JSON\nFrisby.prototype.afterJSON = function(cb) {\n  var self = this;\n  this.current.after.push(function() {\n    var bodyJSON = _jsonParse(self.current.response.body);\n    cb.call(this, bodyJSON);\n  });\n  return this;\n};\n\n// Exception handler callback function\nFrisby.prototype.exceptionHandler = function(fn) {\n  if(_.isUndefined(fn)) {\n    return this._exceptionHandler;\n  }\n  this._exceptionHandler = fn;\n  return this;\n};\n\n//\n// Methods to manually set parts of the response for matcher testing\n//\n\n// Set response from JSON object\nFrisby.prototype.setResponseJSON = function(json) {\n  this.currentRequestFinished = true;\n  this.current.response.body = JSON.stringify(json);\n  return json;\n};\n\n// Set raw response body\nFrisby.prototype.setResponseBody = function(body) {\n  this.currentRequestFinished = true;\n  this.current.response.body = body;\n  return body;\n};\n\n// Set response headers\nFrisby.prototype.setResponseHeaders = function(/* array */ headers) {\n  this.current.response.headers = headers;\n  return headers;\n};\n\n// Set single response header by key with specified value\nFrisby.prototype.setResponseHeader = function(key, value) {\n  this.current.response.headers[key.toLowerCase()] = value.toLowerCase();\n  return this.current.response.headers[key.toLowerCase()];\n};\n\n\n//\n// Toss (Run the current Frisby test)\n//\nFrisby.prototype.toss = function(retry) {\n  var self = this;\n  if (typeof retry === \"undefined\") {\n    retry = self.current.retry;\n  }\n\n  // Assemble all Jasmine tests and RUN them!\n  describe('Frisby Test: ' + self.current.describe, function() {\n\n    // Spec test\n    it(\"\\n\\t[ \" + self.current.itInfo + \" ]\", function() {\n      // Ensure \"it\" scope is accessible to tests\n      var it = this;\n\n      if (self.current.waits > 0) {\n        waits(self.current.waits);\n      }\n\n      // Don't retry POST\n      var retries = (self.current.outgoing.method.toUpperCase() == \"POST\") ? 0 : self.current.retry;\n\n      // we need to loop for the first run + how many times we want to retry\n      // they will abort if the test succeeds\n      for (var x = 0; x < retries + 1; x++) {\n        runs(function() {\n          if (typeof this.n === \"undefined\") {\n            this.n = 0;\n          }\n          else {\n            this.n += 1;\n          }\n          if (this.abort) {\n            return;\n          }\n\n          if (this.n > 0) {\n            it.results_.totalCount = it.results_.passedCount = it.results_.failedCount = 0;\n            it.results_.skipped = false;\n            it.results_.items_ = [];\n\n            process.stdout.write('R');\n\n            waits(self.current.retry_backoff);\n          }\n\n          // Run \"it\" spec\n          self.current.it();\n\n          waitsFor(function(){\n            return self.currentRequestFinished;\n          }, \"HTTP Request timed out before completing\", self._timeout);\n\n          // Run Asserts\n          runs(function() {\n            if (self.currentRequestFinished) {\n              var i;\n              self.current.expectsFailed = true;\n\n              // if you have no expects, they can't fail\n              if (self.current.expects.length == 0) {\n                retry = -1;\n                this.abort = true;\n                self.current.expectsFailed = false;\n              }\n\n              // REQUIRES count for EACH loop iteration (i.e. DO NOT OPTIMIZE THIS LOOP)\n              // Some 'expects' helpers add more tests when executed (recursive 'expectJSON' and 'expectJSONTypes', with nested JSON syntax etc.)\n              for(i=0; i < self.current.expects.length; i++) {\n                if(false !== self._exceptionHandler) {\n                  try {\n                    self.current.expects[i].call(it);\n                  } catch(e) {\n                    self._exceptionHandler.call(self, e);\n                  }\n                } else {\n                  self.current.expects[i].call(it);\n                }\n              }\n\n              if (it.results_.failedCount == 0) {\n                retry = -1;\n                this.abort = true;\n                self.current.expectsFailed = false;\n              }\n            }\n            else {\n              it.results_.failedCount = 1;\n            }\n          });\n        });\n      }\n\n      runs(function() {\n        // AFTER callback\n        if(self.current.after) {\n\n          if (self.current.expectsFailed && self.current.outgoing.inspectOnFailure) {\n            console.log(self.current.itInfo + ' has FAILED with the following response:');\n            self.inspectStatus();\n            self.inspectJSON();\n          };\n\n          // REQUIRES count for EACH loop iteration (i.e. DO NOT OPTIMIZE THIS LOOP)\n          // this enables after to add more after to do things (like inspectJSON)\n          for(i=0; i < self.current.after.length; i++) {\n            var fn = self.current.after[i];\n            if(false !== self._exceptionHandler) {\n              try {\n                fn.call(self);\n              } catch(e) {\n                self._exceptionHandler(e);\n              }\n            } else {\n              fn.call(self);\n            }\n          }\n        }\n      })\n    });\n  });\n};\n\n\n//\n// Add custom Frisby matchers to Jasmine (globally)\n//\njasmine.Matchers.prototype.toMatchOrBeNull = function(expected) {\n  this.message = function() {\n    return \"Expected '\" + this.actual + \"' to match '\" + expected + \"' or be null\";\n  }\n  return (new RegExp(expected).test(this.actual)) || (this.actual === null);\n};\njasmine.Matchers.prototype.toMatchOrBeEmpty = function(expected) {\n  this.message = function() {\n    return \"Expected '\" + this.actual + \"' to match '\" + expected + \"' or be empty\";\n  }\n  return (new RegExp(expected).test(this.actual)) || (this.actual === null) || (this.actual === \"\");\n};\njasmine.Matchers.prototype.toBeType = function(expected) {\n  var aType = _toType(this.actual);\n  var eType = _toType(expected);\n  // Function is not a valid JSON type\n  if(\"function\" === eType) {\n    eType = _toType(expected.prototype);\n  }\n  // Custom failure message\n  this.message = function() {\n    return \"Expected '\" + aType + \"' to be type '\" + eType + \"'\";\n  }\n  // Test\n  return aType === eType;\n};\njasmine.Matchers.prototype.toBeTypeOrNull = function(expected) {\n  var aType = _toType(this.actual);\n  var eType = _toType(expected);\n  // Function is not a valid JSON type\n  if(\"function\" === eType) {\n    eType = _toType(expected.prototype);\n  }\n  // Custom failure message\n  this.message = function() {\n    return \"Expected '\" + aType + \"' to be type '\" + eType + \"' or null\";\n  }\n  // Test\n  return (this.actual === null) || (_toType(this.actual) === eType);\n};\njasmine.Matchers.prototype.toBeTypeOrUndefined = function(expected) {\n  var aType = _toType(this.actual);\n  var eType = _toType(expected);\n  // Function is not a valid JSON type\n  if(\"function\" === eType) {\n    eType = _toType(expected.prototype);\n  }\n  // Custom failure message\n  this.message = function() {\n    return \"Expected '\" + aType + \"' to be type '\" + eType + \"' or null\";\n  }\n  // Test\n  return (this.actual === undefined) || (_toType(this.actual) === eType);\n};\njasmine.Matchers.prototype.toContainJson = function(expected, isNot) {\n  this.message = function() {\n    return \"Actual JSON did not match expected\";\n  }\n\n  // Way of allowing custom failure message - by throwing exceptions in utility function\n  try {\n    return _jsonContains(this.actual, expected);\n  } catch(e) {\n    // Fail test if there is a match failure and it is not an inverse test (for non-match)\n    if(!this.isNot && !isNot) {\n      this.spec.fail(e);\n    }\n  }\n};\njasmine.Matchers.prototype.toContainJsonTypes = function(expected, isNot) {\n  this.message = function() {\n    return \"Actual JSON types did not match expected\";\n  }\n\n  // Way of allowing custom failure message - by throwing exceptions in utility function\n  try {\n    return _jsonContainsTypes(this.actual, expected);\n  } catch(e) {\n    // Fail test if there is a match failure and it is not an inverse test (for non-match)\n    if(!this.isNot && !isNot) {\n      this.spec.fail(e);\n    }\n  }\n};\n\n\n//\n// Parse body as JSON, ensuring not to re-parse when body is already an object (thanks @dcaylor)\n//\nfunction _jsonParse(body) {\n  json = \"\";\n  try {\n    json = (typeof body === \"object\") ? body : JSON.parse(body);\n  } catch(e) {\n    throw new Error(\"Error parsing JSON string: \" + e.message + \"\\n\\tGiven: \" + body);\n  }\n  return json;\n}\n\n\nfunction _jsonContains(jsonBody, jsonTest) {\n  if(typeof jsonTest !== \"object\") {\n    throw new TypeError(\"Expected valid JavaScript object to be given, got \" + typeof expected);\n  }\n\n  // Type check first to prevent potentially confusing errors\n  var aType = _toType(jsonBody);\n  var eType = _toType(jsonTest);\n  // Function is not a valid JSON type\n  if(\"function\" === eType) {\n    eType = _toType(jsonTest.prototype);\n  }\n  if(aType !== eType) {\n    throw new Error(\"Expected '\" + aType + \"' to be type '\" + eType + \"' for comparison\");\n  }\n\n  // Check each matching key/val\n  var errorKeys = [];\n  for(key in jsonTest) {\n\n    // Ensure property exists\n    if(jsonBody) {\n      var kt = typeof jsonTest[key];\n      if(kt === \"object\") {\n        // NESTED expectJSON\n        _jsonContains(jsonBody[key], jsonTest[key]);\n        continue;\n      } else if(kt === \"function\") {\n        var keyType = jsonTest[key].prototype;\n\n        // User-supplied callback (anonymous function)\n        if(_toType(keyType) === \"object\" && arguments.callee.caller.name === \"\") {\n          // Custom matcher function\n          var res = jsonTest[key].call(this, jsonBody[key]);\n          if(typeof res === \"boolean\") {\n            if(true !== res) {\n              throw new Error(\"Expected callback function on key '\" + key + \"' to return true\");\n            }\n          }\n          // Don't do any further assertions for user\n          continue;\n        }\n      } else if(kt !== \"undefined\") {\n        // Jasmine 'toMatch' matcher\n        var test = (jsonBody[key] === jsonTest[key]);\n        if(!test) {\n          throw new Error(\"Expected \" + _toType(jsonBody[key]) + \" '\" + jsonBody[key] + \"' to match \" + _toType(jsonTest[key]) + \" '\" + jsonTest[key] + \"' on key '\" + key + \"'\");\n        }\n      }\n\n      // Do an assertion so assertion count will be consistent\n      expect(true).toBeTruthy();\n    } else {\n      errorKeys.push(key);\n    }\n  };\n\n  if(errorKeys.length > 0) {\n    throw new Error(\"Keys ['\" + errorKeys.join(\"', '\") + \"'] not present in JSON Response body\");\n  }\n\n  return true;\n}\n\n\nfunction _jsonContainsTypes(jsonBody, jsonTest) {\n  // Check each matching key/val\n  var errorKeys = [];\n  for(key in jsonTest) {\n      // Convert type literal to prototype for correct result\n      var kt = _toType(jsonTest[key]);\n      if(kt === \"function\") {\n        var keyType = jsonTest[key].prototype;\n\n        // User-supplied callback (anonymous function)\n        if(_toType(keyType) === \"object\" && arguments.callee.caller.name === \"\") {\n          // Custom matcher function\n          var res = jsonTest[key](jsonBody[key]);\n          if(typeof res === \"boolean\") {\n            if(true !== res) {\n              throw new Error(\"Expected callback function on key '\" + key + \"' to return true\");\n            }\n          }\n          // Don't do any further assertions for user\n          continue;\n        } else {\n          jsonTest[key] = keyType;\n        }\n      } else if(kt === \"object\") {\n        // NESTED expectJSON\n        _jsonContainsTypes(jsonBody[key], jsonTest[key]);\n        continue;\n      }\n\n      // Type check on key (custom Jasmine matcher)\n      var aType = _toType(jsonBody[key]);\n      var eType = _toType(jsonTest[key]);\n      // Function is not a valid JSON type\n      if(\"function\" === eType) {\n        eType = _toType(jsonTest[key].prototype);\n      }\n      if(aType !== eType) {\n        throw new Error(\"Expected '\" + aType + \"' to be type '\" + eType + \"' on key '\" + key + \"'\");\n      }\n\n      // Do an assertion so assertion count will be consistent\n      expect(true).toBeTruthy();\n  };\n\n  if(errorKeys.length > 0) {\n    throw new Error(\"Keys ['\" + errorKeys.join(\"', '\") + \"'] not present in JSON Response body\");\n  }\n\n  return true;\n}\n\n\n//\n// Main Frisby method used to start new spec tests\n//\nexports.create = function(msg) {\n  return new Frisby(msg);\n};\n\nexports.withPath = _withPath;\n\n// Public methods and properties\nexports.globalSetup = globalSetup;\nexports.version = '0.8.5';\n","/home/travis/build/npmtest/node-npmtest-frisby/node_modules/frisby/spec/frisby_global_spec.js":"var frisby = require('../lib/frisby');\n\ndescribe('Frisby object setup', function() {\n\n  it('global setup should be empty', function() {\n    expect({\n      request: {\n        headers: {},\n        inspectOnFailure: false,\n        json: false,\n        baseUri: ''\n      }\n    }).toEqual(frisby.globalSetup());\n  });\n\n  it('should have empty request properties on creation', function() {\n    var f1 = frisby.create('test 1');\n\n    expect({\n      headers: {},\n      inspectOnFailure: false,\n      json: false,\n      baseUri: ''\n    }).toEqual(f1.current.request);\n  });\n\n  it('should be independent of other Frisby objects', function() {\n    var f1 = frisby.create('test 1');\n    var f2 = frisby.create('test 2');\n\n    // Equal setup\n    expect(f1.current.request).toEqual(f2.current.request);\n\n    // Different describe statements\n    expect(f1.current.describe).not.toEqual(f2.current.describe);\n\n    // Add header only to f1\n    f1.addHeaders({\n      'Accept': 'application/json'\n    });\n    f2.addHeaders({\n      'Accept': 'application/x-www-form-urlencoded'\n    });\n\n    // Different setup\n    expect(f1.current.request).not.toEqual(f2.current.request);\n  });\n\n  it('should default to json = false', function() {\n    expect({\n      request: {\n        headers: {},\n        inspectOnFailure: false,\n        json: false,\n        baseUri: ''\n      }\n    }).toEqual(frisby.globalSetup());\n\n    expect(frisby.create('mytest').get('/path').current.outgoing.json).toEqual(false);\n  });\n\n  it('should switch to json default = true when global config is configured json', function() {\n    frisby.globalSetup({\n      request: {\n        headers: {},\n        inspectOnFailure: false,\n        json: true\n      }\n    });\n\n    expect({\n      request: {\n        headers: {},\n        inspectOnFailure: false,\n        json: true\n      }\n    }).toEqual(frisby.globalSetup());\n\n    expect(frisby.create('mytest').get('/path').current.outgoing.json).toEqual(true);\n  });\n\n  it('should be overridable by the params parameter json=false', function() {\n    frisby.globalSetup({\n      request: {\n        headers: {},\n        inspectOnFailure: false,\n        json: true\n      }\n    });\n\n    expect({\n      request: {\n        headers: {},\n        inspectOnFailure: false,\n        json: true\n      }\n    }).toEqual(frisby.globalSetup());\n\n    expect(frisby.create('mytest').get('/path', {\n      json: false\n    }).current.outgoing.json).toEqual(false);\n  });\n\n  it('should switch to inspectOnFailure default = true when global config is configured inspectOnFailure', function() {\n    frisby.globalSetup({\n      request: {\n        headers: {},\n        inspectOnFailure: true,\n        json: false\n      }\n    });\n\n    expect({\n      request: {\n        headers: {},\n        inspectOnFailure: true,\n        json: false\n      }\n    }).toEqual(frisby.globalSetup());\n\n    expect(frisby.create('mytest').get('/path').current.outgoing.inspectOnFailure).toEqual(true);\n  });\n\n  it('should be overridable by the params parameter inspectOnFailure=false', function() {\n    frisby.globalSetup({\n      request: {\n        headers: {},\n        inspectOnFailure: true,\n        json: false\n      }\n    });\n\n    expect({\n      request: {\n        headers: {},\n        inspectOnFailure: true,\n        json: false\n      }\n    }).toEqual(frisby.globalSetup());\n\n    expect(frisby.create('mytest').get('/path', {\n      inspectOnFailure: false\n    }).current.outgoing.inspectOnFailure).toEqual(false);\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-frisby/node_modules/frisby/spec/frisby_httpbin_spec.js":"var frisby = require('../lib/frisby');\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar Readable = require('stream').Readable;\nvar FormData = require('form-data');\n\nfunction StringStream(string, options) {\n    Readable.call(this, options);\n\n    this.writable = false;\n    this.readable = true;\n    this.string = string;\n}\nutil.inherits(StringStream, Readable);\n\nStringStream.prototype._read = function (ignore) {\n    this.push(this.string);\n    this.push(null);\n};\n\n//\n// Tests run like normal Frisby specs but with 'mock' specified with a 'mock-request' object\n// These work without further 'expects' statements because Frisby generates and runs Jasmine tests\n//\ndescribe('Frisby live running httpbin tests', function() {\n\n  it('Frisby basicAuth should work', function() {\n\n    frisby.create('test with httpbin for valid basic auth')\n      .get('http://httpbin.org/basic-auth/frisby/passwd')\n      .auth('frisby', 'passwd')\n      .expectStatus(200)\n    .toss();\n\n  });\n\n  describe('Frisby digestAuth', function() {\n\n    it('should not work if digest not set', function() {\n\n      frisby.create('test with httpbin for invalid digest auth')\n        .auth('frisby', 'passwd')\n        .get('http://httpbin.org/digest-auth/auth/frisby/passwd')\n        .expectStatus(401)\n      .toss();\n\n    });\n\n\n    /*\n    // Digest auth against httpbin not working for some reason\n    // but working fine against my own servers running digest auth\n    it('should work if digest set', function() {\n\n      frisby.create('test with httpbin for valid digest auth')\n        .auth('frisby', 'passwd', true)\n        .get('http://httpbin.org/digest-auth/auth/frisby/passwd')\n        .expectStatus(200)\n      .toss();\n\n    });\n    */\n\n  });\n\n  it('should pass in param hash to request call dependency', function() {\n\n    frisby.create('test with httpbin for valid basic auth')\n      .get('http://httpbin.org/redirect/3', { followRedirect: false, maxRedirects: 1 })\n      .expectStatus(302)\n    .toss();\n\n  });\n\n  it('sending binary data via put or post requests using Buffer objects should work', function() {\n\n      var data = [];\n\n      for(var i=0; i< 1024; i++)\n        data.push(Math.round(Math.random()*256))\n\n\n      frisby.create('POST random binary data via Buffer object')\n        .post('http://httpbin.org/post',\n              new Buffer(data),\n              {\n                  json : false,\n                  headers : {\n                      \"content-type\" : \"application/octet-stream\"\n                  }\n              })\n          .expectStatus(200)\n          .expectHeaderContains('content-type', 'application/json')\n          .expectJSON({\n                  data : 'data:application/octet-stream;base64,'+ new Buffer(data).toString('base64'),\n                  headers: {\n                      \"Content-Type\": \"application/octet-stream\",\n                      \"Content-Length\" : \"1024\"\n                  },\n                  url: \"http://httpbin.org/post\",\n                  json : null,\n                  files: {},\n                  form: {}\n              })\n          .expectJSONTypes({\n                  data: String\n              })\n      .toss();\n\n      frisby.create('PUT random binary data via Buffer object')\n        .put('http://httpbin.org/put',\n              new Buffer(data),\n              {\n                  json : false,\n                  headers : {\n                      \"content-type\" : \"application/octet-stream\"\n                  }\n              })\n          .expectStatus(200)\n          .expectHeaderContains('content-type', 'application/json')\n          .expectJSON({\n                  data : 'data:application/octet-stream;base64,'+ new Buffer(data).toString('base64'),\n                  headers: {\n                      \"Content-Type\": \"application/octet-stream\",\n                      \"Content-Length\" : \"1024\"\n                  },\n                  url: \"http://httpbin.org/put\",\n                  json : null,\n                  files: {},\n                  form: {}\n              })\n          .expectJSONTypes({\n                  data: String\n              })\n      .toss();\n\n  });\n\n  it('PATCH requests with Buffer and Stream objects should work.', function() {\n      var patchCommand = 'Patch me!';\n\n      frisby.create('PATCH via Buffer object')\n          .patch('http://httpbin.org/patch',\n          new Buffer(patchCommand),\n          {\n              json : false,\n              headers : {\n                  \"content-type\" : \"text/plain\"\n              }\n          })\n          .expectStatus(200)\n          .expectHeaderContains('content-type', 'application/json')\n          .expectJSON({\n              data : patchCommand.toString(),\n              headers: {\n                  \"Content-Type\": \"text/plain\",\n                  \"Content-Length\" : String(patchCommand.length)\n              },\n              url: \"http://httpbin.org/patch\",\n              json : null,\n              files: {},\n              form: {}\n          })\n          .expectJSONTypes({\n              data: String\n          })\n          .toss();\n\n      frisby.create('PATCH via Stream object')\n          .patch('http://httpbin.org/patch',\n          new StringStream(patchCommand),\n          {\n              json : false,\n              headers : {\n                  \"content-type\" : \"text/plain\",\n                  \"content-length\" : String(patchCommand.length)\n              }\n          })\n          .expectStatus(200)\n          .expectHeaderContains('content-type', 'application/json')\n          .expectJSON({\n              data : patchCommand.toString(),\n              headers: {\n                  \"Content-Type\": \"text/plain\",\n                  \"Content-Length\" : String(patchCommand.length)\n              },\n              url: \"http://httpbin.org/patch\",\n              json : null,\n              files: {},\n              form: {}\n          })\n          .expectJSONTypes({\n              data: String\n          })\n          .toss();\n\n  });\n\n  it('sending binary data via put or post requests using Stream objects should work', function() {\n        var filePath = path.resolve(__dirname, './logo-frisby.png');\n        var fileSize = fs.statSync(filePath).size;\n        var fileContent = fs.readFileSync(filePath);\n\n        /*\n         * NOTE: Using a Stream with httpbin.org requires to set the Content-Length header to not use chunked\n         *       HTTP transfer. When chunked httpbin does return an empty data field. However not setting the\n         *       Content-Length\n         */\n\n        frisby.create('POST frisby logo to http://httpbin.org/post using a Stream')\n            .post('http://httpbin.org/post',\n                fs.createReadStream(filePath),\n                {\n                    json: false,\n                    headers: {\n                        \"content-type\": \"application/octet-stream\",\n                        \"content-length\": fileSize\n                    }\n                })\n                .expectStatus(200)\n                .expectHeaderContains('content-type', 'application/json')\n                .expectJSON({\n                    data: 'data:application/octet-stream;base64,' + fileContent.toString('base64'),\n                    headers: {\n                        \"Content-Type\": \"application/octet-stream\",\n                        \"Content-Length\": String(fileSize)\n                    },\n                    url: 'http://httpbin.org/post'\n                })\n                .expectJSONTypes({\n                    data: String\n                })\n                .toss();\n\n        frisby.create('PUT frisby logo to http://httpbin.org/put using a Stream')\n            .put('http://httpbin.org/put',\n                fs.createReadStream(filePath),\n                {\n                    json: false,\n                    headers: {\n                        \"Content-Type\": \"application/octet-stream\",\n                        \"Content-Length\": fileSize\n                    }\n                })\n                .expectStatus(200)\n                .expectHeaderContains('content-type', 'application/json')\n                .expectJSON({\n                    data: 'data:application/octet-stream;base64,' + fileContent.toString('base64'),\n                    headers: {\n                        \"Content-Type\": \"application/octet-stream\",\n                        \"Content-Length\": String(fileSize)\n                    },\n                    url: 'http://httpbin.org/put'\n                })\n                .expectJSONTypes({\n                    data: String\n                })\n                .toss();\n    });\n\n  it('sending multipart/from-data encoded bodies should work', function () {\n\n    var logoPath = path.resolve(__dirname, '../spec/logo-frisby.png');\n\n    var binaryData = [0xDE, 0xCA, 0xFB, 0xAD];\n\n    function makeFormData() {\n      var form = new FormData();\n\n      form.append('field_a', 'A');\n      form.append('field_b', 'B');\n\n      form.append('buffer', new Buffer(binaryData), {\n        contentType: 'application/octet-stream',\n        filename: 'test.bin'               // using Buffers, we need to pass a filename to make form-data set the content-type\n      });\n\n      form.append('file_1', fs.createReadStream(logoPath), {\n        knownLength: fs.statSync(logoPath).size         // we need to set the knownLength so we can call  form.getLengthSync()\n      });\n\n      form.append('file_2', fs.createReadStream(__filename), {\n        knownLength: fs.statSync(__filename).size       // we need to set the knownLength so we can call  form.getLengthSync()\n      });\n      return form;\n    }\n\n    var form = makeFormData();\n\n    frisby.create('POST frisby logo to http://httpbin.org/post')\n      .post('http://httpbin.org/post',\n      form,\n      {\n        json: false,\n        headers: {\n          'content-type': 'multipart/form-data; boundary=' + form.getBoundary(),\n          'content-length': form.getLengthSync()\n        }\n      })\n      .expectStatus(200)\n      .expectHeaderContains('content-type', 'application/json')\n      .expectJSON({\n        data: '', // empty, data is returned in the files and form propierties\n        headers: {\n          \"Content-Type\": 'multipart/form-data; boundary=' + form.getBoundary()\n        },\n        url: 'http://httpbin.org/post',\n        json: null,\n        files: {\n          buffer: 'data:application/octet-stream;base64,' + new Buffer(binaryData).toString('base64'),\n          file_1: 'data:image/png;base64,' + fs.readFileSync(logoPath).toString('base64'),\n          file_2: fs.readFileSync(__filename).toString()\n        },\n        form: {\n          field_a: 'A',\n          field_b: 'B'\n        }\n      })\n      .expectJSONTypes({\n        data: String,\n        form: {\n          field_a: String,\n          field_b: String\n        },\n        files: {\n          buffer: String,\n          file_1: String,\n          file_2: String\n        }\n      })\n      .toss();\n\n    form = makeFormData();  // FormData is a Stream and it has been consumed!\n\n    frisby.create('PUT frisby logo to http://httpbin.org/post')\n      .put('http://httpbin.org/put',\n      form,\n      {\n        json: false,\n        headers: {\n          'content-type': 'multipart/form-data; boundary=' + form.getBoundary(),\n          'content-length': form.getLengthSync()\n        }\n      })\n      .expectStatus(200)\n      .expectHeaderContains('content-type', 'application/json')\n      .expectJSON({\n        data: '', // empty, data is returned in the files and form propierties\n        headers: {\n          \"Content-Type\": 'multipart/form-data; boundary=' + form.getBoundary()\n        },\n        url: 'http://httpbin.org/put',\n        json: null,\n        files: {\n          buffer: 'data:application/octet-stream;base64,' + new Buffer(binaryData).toString('base64'),\n          file_1: 'data:image/png;base64,' + fs.readFileSync(logoPath).toString('base64'),\n          file_2: fs.readFileSync(__filename).toString()\n        },\n        form: {\n          field_a: 'A',\n          field_b: 'B'\n        }\n      })\n      .expectJSONTypes({\n        data: String,\n        form: {\n          field_a: String,\n          field_b: String\n        },\n        files: {\n          buffer: String,\n          file_1: String,\n          file_2: String\n        }\n      })\n      .toss();\n\n    form = makeFormData();  // FormData is a Stream and it has been consumed!\n\n    frisby.create('PATCH frisby logo to http://httpbin.org/post')\n      .patch('http://httpbin.org/patch',\n      form,\n      {\n        json: false,\n        headers: {\n          'content-type': 'multipart/form-data; boundary=' + form.getBoundary(),\n          'content-length': form.getLengthSync()\n        }\n      })\n      .expectStatus(200)\n      .expectHeaderContains('content-type', 'application/json')\n      .expectJSON({\n        data: '', // empty, data is returned in the files and form propierties\n        headers: {\n          \"Content-Type\": 'multipart/form-data; boundary=' + form.getBoundary()\n        },\n        url: 'http://httpbin.org/patch',\n        json: null,\n        files: {\n          buffer: 'data:application/octet-stream;base64,' + new Buffer(binaryData).toString('base64'),\n          file_1: 'data:image/png;base64,' + fs.readFileSync(logoPath).toString('base64'),\n          file_2: fs.readFileSync(__filename).toString()\n        },\n        form: {\n          field_a: 'A',\n          field_b: 'B'\n        }\n      })\n      .expectJSONTypes({\n        data: String,\n        form: {\n          field_a: String,\n          field_b: String\n        },\n        files: {\n          buffer: String,\n          file_1: String,\n          file_2: String\n        }\n      })\n      .toss();\n\n  })\n});\n","/home/travis/build/npmtest/node-npmtest-frisby/node_modules/frisby/spec/frisby_json_schema_spec.js":"var nock = require('nock');\nvar frisby = require('../lib/frisby');\nvar path = require('path');\n\n// Nock to intercept HTTP requests for testing\nnock('http://example.com', { allowUnmocked: false })\n  .persist()\n  // @link http://json-schema.org/example1.html\n  .get('/response1')\n  .reply(200, {\n    \"id\": 1,\n    \"name\": \"A green door\",\n    \"price\": 12.50,\n    \"tags\": [\"home\", \"green\"]\n  })\n  .get('/response2')\n  .reply(200, {\n    response: {\n      \"id\": 1,\n      \"name\": \"A green door\",\n      \"price\": 12.50,\n      \"tags\": [\"home\", \"green\"]\n    }\n  })\n  .get('/response_x')\n  .reply(200, {\n    response: {\n      data: {\n        \"id_x\": 1,\n        \"name_x\": \"A green door\",\n        \"price_x\": 12.50,\n        \"tags_x\": [\"home\", \"green\"]\n      }\n    }\n  })\n  .get('/response-array')\n  .reply(200, {\n    items: [\n      {\n        \"id\": 1,\n        \"name\": \"A green door\",\n        \"price\": 12.50,\n        \"tags\": [\"home\", \"green\"]\n      },\n      {\n        \"id\": 2,\n        \"name\": \"A blue door\",\n        \"price\": 13.50,\n        \"tags\": [\"home\", \"blue\"]\n      },\n      {\n        \"id\": 3,\n        \"name\": \"A screen door\",\n        \"price\": 21.25,\n        \"tags\": [\"home\", \"screen\", \"door\"]\n      }\n    ]\n  })\n;\n\n//\n// Tests\n//\ndescribe('Frisby JSONSchema', function() {\n\n  it('should accept and validate JSONSchema object', function() {\n    frisby.create(this.description)\n      .get('http://example.com/response1')\n      .expectStatus(200)\n      .expectJSONSchema({\n        \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n        \"title\": \"Product\",\n        \"description\": \"A product from Acme's catalog\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"description\": \"The unique identifier for a product\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"Name of the product\",\n            \"type\": \"string\"\n          },\n          \"price\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"exclusiveMinimum\": true\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"minItems\": 1,\n            \"uniqueItems\": true\n          }\n        },\n        \"required\": [\"id\", \"name\", \"price\"]\n      })\n    .toss();\n  });\n\n  it('should accept and validate JSONSchema file with relative path', function() {\n    frisby.create(this.description)\n      .get('http://example.com/response1')\n      .expectStatus(200)\n      .expectJSONSchema('fixtures/json_schema/response1.json')\n    .toss();\n  });\n\n  it('should accept and validate JSONSchema file with full root path', function() {\n    frisby.create(this.description)\n      .get('http://example.com/response1')\n      .expectStatus(200)\n      .expectJSONSchema(path.join(__dirname, 'fixtures/json_schema/response1.json'))\n    .toss();\n  });\n\n  it('should accept and validate JSONSchema object with path syntax', function() {\n    frisby.create(this.description)\n      .get('http://example.com/response2')\n      .expectStatus(200)\n      .expectJSONSchema('response', {\n        \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n        \"title\": \"Product\",\n        \"description\": \"A product from Acme's catalog\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"description\": \"The unique identifier for a product\",\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"description\": \"Name of the product\",\n            \"type\": \"string\"\n          },\n        },\n      })\n    .toss();\n  });\n\n  it('should accept and validate JSONSchema file with jsonPath syntax', function() {\n    frisby.create(this.description)\n      .get('http://example.com/response2')\n      .expectStatus(200)\n      .expectJSONSchema('response', 'fixtures/json_schema/response1.json')\n    .toss();\n  });\n\n  it('should accept and validate JSONSchema file with jsonPath array syntax', function() {\n    frisby.create(this.description)\n      .get('http://example.com/response-array')\n      .expectStatus(200)\n      .expectJSONSchema('items.*', 'fixtures/json_schema/response1.json')\n    .toss();\n  });\n\n  it('should accept and validate JSONSchema file with jsonPath syntax', function() {\n    frisby.create(this.description)\n      .get('http://example.com/response_x')\n      .expectStatus(200)\n      .not().expectJSONSchema('response.data', 'fixtures/json_schema/response1.json')\n    .toss();\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-frisby/node_modules/frisby/spec/frisby_matchers_spec.js":"var frisby = require('../lib/frisby');\nvar mockRequest = require('mock-request')\n\n\ndescribe('Frisby matchers', function() {\n\n  it('toContainJSON should match exactly', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).toContainJson({\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    });\n    expect(testJson).not.toContainJson({\n      test_str: \"I am NOT a string!\",\n      test_int: \"43\",\n      test_float: 43.43\n    });\n  });\n\n\n  it('toContainJSON should match callbacks', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).toContainJson({\n      test_str: \"I am a string!\",\n      test_int: function(val) { expect(val).toMatch(/\\d+/); }\n    });\n  });\n\n\n  it('toContainJSON should NOT match with invalid callbacks', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).toContainJson({\n      test_str: \"I am a string!\",\n      test_int: function(val) { expect(val).not.toMatch('blah'); }\n    });\n  });\n\n\n  it('Callbacks should be able to use matcher toBeTypeOrNull', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_optional: null,\n      test_nest: {\n        nested_optional: null\n      }\n    };\n\n    // Expectation\n    expect(testJson).toContainJson({\n      test_str: \"I am a string!\",\n      test_optional: function(val) { expect(val).toBeTypeOrNull(String); },\n      test_nest: {\n        nested_optional: function(val) { expect(val).toBeTypeOrNull(String); }\n      }\n    });\n  });\n\n  it('Callbacks should be able to use matcher toBeTypeOrUndefined', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_optional: \"I am optional key\",\n      test_nest: {\n        nested_optional: \"I am optional key too\"\n      }\n    };\n\n    // Expectation\n    expect(testJson).toContainJson({\n      test_str: \"I am a string!\",\n      test_optional: function(val) { expect(val).toBeTypeOrUndefined(String); },\n      test_optional_nonexist: function(val) { expect(val).toBeTypeOrUndefined(String); },\n      test_nest: {\n        nested_optional: function(val) { expect(val).toBeTypeOrUndefined(String); },\n        nested_optional_nonexist: function(val) { expect(val).toBeTypeOrUndefined(String); }\n      }\n    });\n  });\n\n  it('toContainJSON should match callbacks that return boolean true', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).toContainJson({\n      test_str: \"I am a string!\",\n      test_int: function(val) { return true; }\n    });\n  });\n\n\n  it('toContainJSON should NOT match callbacks that return boolean false', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).not.toContainJson({\n      test_str: \"I am a string!\",\n      test_int: function(val) { return false; }\n    });\n  });\n\n\n  it('toContainJSON should pass when callbacks return anything other than boolean false', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).toContainJson({\n      test_str: function(val) { return 'anything other than boolean false'; },\n      test_int: function(val) { return 42; },\n      test_float: function(val) { return; }\n    });\n  });\n\n\n  it('toContainJSON should not match with undefined variable', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).not.toContainJson(undefined);\n  });\n\n\n  it('toContainJSON should not match with non-existent JSON key', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).not.toContainJson({\n      test_str: \"I am a string!\",\n      test: \"Some random value that won't match anyways\" // Key that does not exist\n    });\n  });\n\n\n  it('JSONTypes should match String', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).toContainJsonTypes({\n      test_str: String,\n      test_int: Number\n    });\n  });\n\n\n  it('JSONTypes should match String', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).toContainJsonTypes({\n      test_str: String,\n      test_int: Number\n    });\n  });\n\n\n  it('JSONTypes should not match String for integer type', function() {\n    // Expectation\n    expect({\n      test_int: 42,\n    }).not.toContainJsonTypes({\n      test_int: String,\n    });\n  });\n\n\n  it('JSONTypes should not match Number for string type', function() {\n    // Expectation\n    expect({\n      test_str: \"I am a string!\",\n    }).not.toContainJsonTypes({\n      test_str: Number,\n    });\n  });\n\n\n  it('JSONTypes should not match with non-existent JSON key', function() {\n    // Set fake JSON body\n    var testJson = {\n      test_str: \"I am a string!\",\n      test_int: 42,\n      test_float: 42.42\n    };\n\n    // Expectation\n    expect(testJson).not.toContainJsonTypes({\n      test_str: String,\n      test: String // Key that does not exist\n    });\n  });\n\n\n  it('toContainJson should continue checking matches after nested object', function() {\n    // Expectation\n    expect({\n      test_str: \"I am a string!\",\n      test_obj: {\n        foo: 'bar',\n        bar: 'baz'\n      },\n      test_int: 42\n    }).not.toContainJson({\n      test_str: \"I am a string!\",\n      test_obj: {\n        foo: 'bar',\n        bar: 'baz'\n      },\n      test_int: 4242\n    });\n  });\n\n\n  it('toContainJson should fail on non-matching objects inside an array', function() {\n    // Expectation\n    expect({\n      test_str: \"I am a string!\",\n      test_objs: [\n        { foo: 'bar' },\n        { bar: 'baz' }\n      ],\n      test_int: 42\n    }).not.toContainJson({\n      test_str: \"I am a string!\",\n      test_objs: [\n        { foo: 'bar' },\n        { bar: 'barX' }\n      ],\n      test_int: 42\n    });\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-frisby/node_modules/frisby/spec/frisby_withpath_spec.js":"var frisby = require('../lib/frisby');\n\ndescribe('Frisby withPath syntax', function() {\n\n  it('should work with single string path', function() {\n    frisby.withPath('response', {\n        response: {\n          foo: 'bar',\n          bar: 'baz',\n          one: 1\n        }\n      }, function(jsonBody) {\n      expect(jsonBody).toEqual({\n        foo: 'bar',\n        bar: 'baz',\n        one: 1\n      });\n    });\n  });\n\n  it('should work with nested dot-separated string path', function() {\n    frisby.withPath('response.data', {\n        response: {\n          data: {\n            foo: 'bar',\n            bar: 'baz',\n            one: 1\n          }\n        }\n      }, function(jsonBody) {\n      expect(jsonBody).toEqual({\n        foo: 'bar',\n        bar: 'baz',\n        one: 1\n      });\n    });\n  });\n\n  it('should work with asterisk to iterate over array of objects', function() {\n    var count = 0;\n    frisby.withPath('response.items.*', {\n        response: {\n          items: [{\n              foo: 'bar',\n              bar: 'baz',\n              one: 1\n            },{\n              foo: 'bar',\n              bar: 'baz',\n              one: 1\n            },{\n              foo: 'bar',\n              bar: 'baz',\n              one: 1\n            }\n          ]\n        }\n      }, function(jsonBody) {\n        ++count;\n        expect(jsonBody).toEqual({\n          foo: 'bar',\n          bar: 'baz',\n          one: 1\n        });\n    });\n    expect(count).toEqual(3);\n  });\n\n  it('should work with question mark to match at least one of the items in an array', function() {\n    var count = 0;\n    frisby.withPath('response.items.?', {\n        response: {\n          items: [{\n              foo: 'bar',\n              bar: 'baz',\n              one: 1\n            },{\n              foo: 'bar2',\n              bar: 'baz2',\n              one: 2\n            },{\n              foo: 'bar3',\n              bar: 'baz3',\n              one: 3\n            }\n          ]\n        }\n      }, function(jsonBody) {\n        ++count;\n        // Exception should not be shown because at least ONE iteration will not throw an exception\n        if(jsonBody.foo !== 'bar') {\n          throw new Error('Property foo did not match bar');\n        }\n    });\n    expect(count).toEqual(3);\n  });\n\n  it('should work with ampersand to iterate over keys of objects', function() {\n    var count = 0;\n    frisby.withPath('response.&', {\n        response: {\n          foo: 'bar',\n          bar: 'baz',\n          one: 'one'\n        }\n      }, function(jsonBody) {\n        ++count;\n        expect(jsonBody).toBeType(String);\n    });\n    expect(count).toEqual(3);\n  });\n});\n"}